<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jupiter Jayna's Plotter Art Control Centre</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="layout">
        <button id="toggleDebug">Hide</button>
        <div class="canvas-area">
            <div id="svgContainer"></div>
        </div>
        <div class="debug-panel">
            <div class="panel-title">
                <h2>Jupiter Jayna's Plotter Art Control Centre</h2>
            </div>
            <div class="preview-section">
                <h3>Drawing Control</h3>
                <div class="preview-controls">
                    <div class="control-section">
                        <h4>Drawing</h4>
                        <div class="control-section-content">
                            <select id="drawingSelect"></select>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <h4>Preview</h4>
                        <div class="control-section-content">
                            <button id="toggleOrientation">Portrait</button>
                            <button id="toggleRulers">Show Ruler</button>
                            <button id="updateSvg">Update Preview</button>
                            <button id="toggleRefresh" class="paused">Resume Refresh</button>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <h4>SVG</h4>
                        <div class="control-section-content">
                            <button id="exportSvg">Export SVG</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="plotter-section">
                <h3>Plotter Control</h3>
                <div class="plotter-controls">
                    <div class="control-section">
                        <h4>Plot</h4>
                        <div class="control-section-content">
                            <select id="layerSelect">
                                <option value="all">Show All Layers</option>
                            </select>
                            <button id="plotterPlotLayer" class="plotter-button" disabled>Plot Current Layer</button>
                            <button id="plotterStopPlot" class="plotter-button danger">Stop Plot</button>
                        </div>
                    </div>
                    <div class="control-section">
                        <h4>Paper</h4>
                        <div class="control-section-content">
                            <select id="paperSelect" class="plotter-button">
                                <option value="A3">A3 (297×420mm)</option>
                                <option value="A4">A4 (210×297mm)</option>
                                <option value="Square297">Square (297×297mm)</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-section">
                        <h4>Setup</h4>
                        <div class="control-section-content">
                            <button id="plotterHome" class="plotter-button">Home</button>
                            <button id="plotterCycle" class="plotter-button">Cycle</button>
                            <button id="plotterAlign" class="plotter-button">Align</button>
                            <button id="plotterToggle" class="plotter-button">Toggle</button>
                            <button id="plotterDisableMotors" class="plotter-button">Disable Motors</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="debug-section">
                <h3>Messages</h3>
                <div class="debug-tabs">
                    <button class="tab-button active" data-tab="all">All</button>
                    <button class="tab-button" data-tab="plots">Just Plots</button>
                </div>
                <div id="debugLog"></div>
            </div>
        </div>
    </div>

    <script type="module">
        let progressEventSource = null;

        function startProgressListener() {
            if (progressEventSource) {
                progressEventSource.close();
            }
            
            logDebug('Starting progress listener...');
            progressEventSource = new EventSource('http://localhost:8000/plot-progress');
            
            progressEventSource.onmessage = function(event) {
                try {
                    console.log('SSE message received:', event.data);  // Debug log
                    const data = JSON.parse(event.data);
                    if (data.progress) {
                        if (data.progress === 'PLOT_COMPLETE') {
                            // Special message to re-enable controls
                            updatePlotterStatus('Ready', true);
                            // Re-enable all preview controls
                            document.querySelectorAll('.preview-section button, .preview-section select').forEach(control => {
                                control.disabled = false;
                            });
                            // Close SSE connection as plot is complete
                            if (progressEventSource) {
                                progressEventSource.close();
                                progressEventSource = null;
                            }
                        } else if (data.progress === 'PLOT_ERROR') {
                            // Handle plot errors
                            updatePlotterStatus('Ready', true);
                            // Re-enable all preview controls
                            document.querySelectorAll('.preview-section button, .preview-section select').forEach(control => {
                                control.disabled = false;
                            });
                            // Close SSE connection as plot has errored
                            if (progressEventSource) {
                                progressEventSource.close();
                                progressEventSource = null;
                            }
                        } else {
                            // Check if the message contains an error
                            if (data.progress.toLowerCase().includes('error')) {
                                logDebug(data.progress, 'error');
                            } else {
                                logDebug(data.progress, 'info');
                            }
                        }
                    }
                } catch (error) {
                    console.error('SSE parse error:', error);  // Debug log
                    logDebug(`Error parsing progress data: ${error}`, 'error');
                }
            };
            
            progressEventSource.onerror = function(error) {
                console.error('SSE error:', error);  // Debug log
                logDebug('Progress listener error, reconnecting...', 'error');
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
                // Attempt to reconnect after a short delay
                setTimeout(startProgressListener, 1000);
            };

            progressEventSource.onopen = function() {
                console.log('SSE connection opened');  // Debug log
                logDebug('Progress listener connected');
            };
        }

        // Make logDebug available globally
        window.logDebug = function(message, type = 'info') {
            const debugLog = document.getElementById('debugLog');
            
            // Remove bold from previous last message if it exists
            const previousLastEntry = debugLog.lastElementChild;
            if (previousLastEntry) {
                previousLastEntry.style.fontWeight = 'normal';
            }
            
            const entry = document.createElement('div');
            entry.className = `debug-entry debug-${type}`;
            entry.dataset.isPlot = message.startsWith('Plotting') ? 'true' : 'false';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.style.fontWeight = 'bold';  // Make new entry bold
            console.log(entry);
            debugLog.appendChild(entry);
            debugLog.scrollTop = debugLog.scrollHeight;
            
            // Keep only last 100 messages
            while (debugLog.children.length > 100) {
                debugLog.removeChild(debugLog.firstChild);
            }

            // Update visibility based on current tab
            const activeTab = document.querySelector('.tab-button.active').dataset.tab;
            if (activeTab === 'plots' && !message.startsWith('Plotting')) {
                entry.style.display = 'none';
            }
        }

        // Add tab switching functionality
        document.addEventListener('DOMContentLoaded', function() {
            const tabButtons = document.querySelectorAll('.tab-button');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active state
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Show/hide messages based on tab
                    const entries = document.querySelectorAll('.debug-entry');
                    entries.forEach(entry => {
                        if (this.dataset.tab === 'all') {
                            entry.style.display = '';
                        } else if (this.dataset.tab === 'plots') {
                            entry.style.display = entry.dataset.isPlot === 'true' ? '' : 'none';
                        }
                    });
                });
            });
        });
        const select = document.getElementById('drawingSelect');
        const container = document.getElementById('svgContainer');
        const exportButton = document.getElementById('exportSvg');

        async function updateSvg() {
            stopRefresh();  // Stop auto-refresh
            await draw();   // Do a single draw
            populateLayerSelect();
            updatePlotterStatus();
            logDebug('Manual SVG update triggered');
        }

        async function exportSvg() {
            const svg = container.querySelector('svg');
            if (!svg) {
                return;
            }

            try {
                // Get the current drawing configuration
                const { drawings } = await import('./js/drawings.js?v=' + Date.now());
                const currentConfig = drawings[select.value];

                // Serialize SVG
                const svgData = new XMLSerializer().serializeToString(svg);

                // Send to server with full config
                const response = await fetch('http://localhost:8000/save-svg', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: select.value,
                        svg: svgData,
                        config: currentConfig
                    })
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log(`SVG saved to ${result.filename}`);
                    logDebug(`SVG saved to ${result.filename}`);
                }
            } catch (error) {
                console.error('Error saving SVG:', error);
                logDebug('Error saving SVG: ' + error.message, 'error');
            }
        }

        function updateLayerVisibility() {
            const svg = container.querySelector('svg');
            if (!svg) return;

            const selectedLayer = document.getElementById('layerSelect').value;
            const layers = svg.querySelectorAll('g[inkscape\\:groupmode="layer"]');
            
            layers.forEach(layer => {
                const label = layer.getAttribute('inkscape:label');
                const layerIndex = label.split('-')[0];
                if (selectedLayer === 'all' || layerIndex === selectedLayer) {
                    layer.style.display = '';
                } else {
                    layer.style.display = 'none';
                }
            });
        }

        function populateLayerSelect() {
            const svg = container.querySelector('svg');
            if (!svg) return;

            const layerSelect = document.getElementById('layerSelect');
            const layers = svg.querySelectorAll('g[inkscape\\:groupmode="layer"]');
            
            // Get unique color indices
            const colorIndices = new Set();
            layers.forEach(layer => {
                const label = layer.getAttribute('inkscape:label');
                const colorIndex = label.split('-')[0];
                colorIndices.add(colorIndex);
            });

            // Clear existing options except "Show All Layers"
            layerSelect.innerHTML = '<option value="all">Show All Layers</option>';
            
            // Get all unique labels and their indices, but only for layers that have content
            const layerInfo = new Map();
            layers.forEach(layer => {
                // Only include layers that have child elements (paths, etc)
                if (layer.children.length > 0) {
                    const label = layer.getAttribute('inkscape:label');
                    const index = label.split('-')[0];
                    layerInfo.set(index, label);
                }
            });

            // Add an option for each layer that has content
            Array.from(layerInfo.entries())
                .sort(([a], [b]) => Number(a) - Number(b))
                .forEach(([index, label]) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = label;
                    layerSelect.appendChild(option);
                });
        }

        // Store ruler visibility state
        let rulersVisible = false;

        async function draw() {
            try {
                logDebug('Reloading modules...');
                // Reload the modules fresh each time
                const { generateSVG } = await import('./js/app.js?v=' + Date.now());
                const { drawings } = await import('./js/drawings.js?v=' + Date.now());
                
                // First time only: populate select options
                if (!select.options.length) {
                    select.innerHTML = Object.entries(drawings)
                        .map(([key, drawing]) => 
                            `<option value="${key}">${drawing.name}</option>`)
                        .join('');
                }

                // Store current states
                const selectedDrawing = drawings[select.value];
                logDebug(`Generating drawing: ${selectedDrawing.name}`);
                const currentLayer = document.getElementById('layerSelect').value;
                const orientationButton = document.getElementById('toggleOrientation');
                const isLandscape = orientationButton.textContent === 'Landscape';
                orientationButton.textContent = isLandscape ? 'Landscape' : 'Portrait';
                container.innerHTML = '';
                const svg = generateSVG(selectedDrawing);
                svg.setAttribute('preserveAspectRatio', 'none');
                
                // Get the actual content dimensions from the drawing data
                const contentWidth = selectedDrawing.drawingData.width;
                const contentHeight = selectedDrawing.drawingData.height;
                
                // Restore orientation if needed
                if (isLandscape) {
                    const { setOrientation } = await import('./js/svgUtils.js?v=' + Date.now());
                    setOrientation(svg, true, contentWidth, contentHeight);
                }
                container.appendChild(svg);
                populateLayerSelect();
                document.getElementById('layerSelect').value = currentLayer;
                updateLayerVisibility();
                
                // Apply stored ruler visibility
                const rulerGroup = svg.querySelector('g.preview-only');
                const marginRect = svg.querySelector('rect.preview-only');
                if (rulerGroup && marginRect) {
                    rulerGroup.style.display = rulersVisible ? '' : 'none';
                    marginRect.style.display = rulersVisible ? '' : 'none';
                }
            } catch (error) {
                console.error('Error:', error);
                logDebug('Error generating SVG: ' + error.message, 'error');
            }
        }

        let refreshInterval;

        function startRefresh() {
            logDebug('Starting automatic refresh');
            draw();
            refreshInterval = setInterval(draw, 1000);
            const toggleButton = document.getElementById('toggleRefresh');
            toggleButton.textContent = 'Pause Refresh';
            toggleButton.classList.remove('paused');
        }

        function stopRefresh() {
            if (refreshInterval) {
                logDebug('Pausing automatic refresh');
                clearInterval(refreshInterval);
                refreshInterval = null;
                const toggleButton = document.getElementById('toggleRefresh');
                toggleButton.textContent = 'Resume Refresh';
                toggleButton.classList.add('paused');
            }
        }

        function toggleRefresh() {
            if (refreshInterval) {
                stopRefresh();
            } else {
                startRefresh();
            }
        }

        async function toggleOrientation() {
            const svg = container.querySelector('svg');
            if (!svg) return;
            
            const { setOrientation } = await import('./js/svgUtils.js?v=' + Date.now());
            
            // Toggle between portrait and landscape
            const isRotated = svg.querySelector('g.content-group')?.getAttribute('transform')?.includes('rotate');
            
            // Get the current drawing configuration
            const { drawings } = await import('./js/drawings.js?v=' + Date.now());
            const currentConfig = drawings[select.value];
            const contentWidth = currentConfig.drawingData.width;
            const contentHeight = currentConfig.drawingData.height;
            
            setOrientation(svg, !isRotated, contentWidth, contentHeight);
            
            // Update button text
            const button = document.getElementById('toggleOrientation');
            button.textContent = isRotated ? 'Portrait' : 'Landscape';
            logDebug(`Switched to ${button.textContent} orientation`);

            // Force redraw if refresh is paused
            if (!refreshInterval) {
                // Store current layer selection and SVG attributes
                const currentLayer = document.getElementById('layerSelect').value;
                const { drawings } = await import('./js/drawings.js?v=' + Date.now());
                const currentConfig = drawings[select.value];
                
                // Generate fresh SVG to ensure correct dimensions
                const { generateSVG } = await import('./js/app.js?v=' + Date.now());
                const newSvg = generateSVG(currentConfig);
                
                // Apply current orientation
                setOrientation(newSvg, !isRotated, contentWidth, contentHeight);
                
                // Update container
                container.innerHTML = '';
                container.appendChild(newSvg);
                
                // Restore layer visibility
                populateLayerSelect();
                document.getElementById('layerSelect').value = currentLayer;
                updateLayerVisibility();
            }
        }

        // Toggle debug panel visibility
        function toggleDebugPanel() {
            const debugPanel = document.querySelector('.debug-panel');
            const toggleButton = document.getElementById('toggleDebug');
            debugPanel.classList.toggle('hidden');
            toggleButton.textContent = debugPanel.classList.contains('hidden') ? 'Show' : 'Hide';
        }

        // Draw once but don't start refresh
        draw();
        logDebug('Initial draw complete. Auto-refresh is off.');

        // Handle drawing selection changes
        select.addEventListener('change', async () => {
            await draw();
            populateLayerSelect();
            updatePlotterStatus();
        });
        
        // Handle layer select interactions
        document.getElementById('layerSelect').addEventListener('focus', () => {
            // Store current refresh state
            const wasRefreshing = !!refreshInterval;
            stopRefresh();
            // Store state on the element
            document.getElementById('layerSelect').dataset.wasRefreshing = wasRefreshing;
        });
        
        document.getElementById('layerSelect').addEventListener('blur', () => {
            // Restore previous refresh state
            const wasRefreshing = document.getElementById('layerSelect').dataset.wasRefreshing === 'true';
            if (wasRefreshing) {
                startRefresh();
            }
        });
        
        document.getElementById('layerSelect').addEventListener('change', (e) => {
            updateLayerVisibility();
            updatePlotterStatus();  // Add this line to update plotter button states
            e.target.blur();
        });
        exportButton.addEventListener('click', exportSvg);
        document.getElementById('updateSvg').addEventListener('click', updateSvg);
        document.getElementById('toggleRefresh').addEventListener('click', toggleRefresh);
        document.getElementById('toggleDebug').addEventListener('click', toggleDebugPanel);
        document.getElementById('toggleOrientation').addEventListener('click', toggleOrientation);
        
        // Ruler visibility toggle
        document.getElementById('toggleRulers').addEventListener('click', () => {
            const button = document.getElementById('toggleRulers');
            const svg = container.querySelector('svg');
            const rulerGroup = svg.querySelector('g.preview-only');
            const marginRect = svg.querySelector('rect.preview-only');
            
            if (rulerGroup && marginRect) {
                rulersVisible = rulerGroup.style.display !== 'none';
                if (!rulersVisible) {
                    rulerGroup.style.display = '';
                    marginRect.style.display = '';
                    button.textContent = 'Hide Ruler';
                    logDebug('Showing ruler and margin');
                } else {
                    rulerGroup.style.display = 'none';
                    marginRect.style.display = 'none';
                    button.textContent = 'Show Ruler';
                    logDebug('Hidden ruler and margin');
                }
                rulersVisible = !rulersVisible;
            }
        });

        // Plotter control functions
        async function sendPlotterCommand(command, data = {}) {
            try {
                const response = await fetch('http://localhost:8000/plotter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        command,
                        ...data
                    })
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    logDebug(`Plotter command ${command} successful`);
                    return true;
                } else {
                    throw new Error(result.message || 'Unknown error');
                }
            } catch (error) {
                logDebug(`Plotter command ${command} failed: ${error.message}`, 'error');
                return false;
            }
        }

        function updatePlotterStatus(status, isConnected = false) {
            // Get all control elements
            const plotButtons = document.querySelectorAll('.plotter-button');
            const stopButton = document.getElementById('plotterStopPlot');
            const plotLayerButton = document.getElementById('plotterPlotLayer');
            const layerSelect = document.getElementById('layerSelect');
            const previewControls = document.querySelectorAll('.preview-section button, .preview-section select');
            
            if (status === 'Plotting') {
                // During plotting, disable all controls except Stop Plot button
                plotButtons.forEach(button => {
                    if (button !== stopButton) {
                        button.disabled = true;
                    }
                });
                // Ensure stop button is enabled
                stopButton.disabled = false;
                // Disable layer select
                layerSelect.disabled = true;
                // Disable all preview controls
                previewControls.forEach(control => {
                    control.disabled = true;
                });
            } else {
                // When not plotting, restore normal control states
                plotButtons.forEach(button => {
                    if (button === plotLayerButton) {
                        // Plot Layer button is enabled only when a specific layer is selected
                        button.disabled = layerSelect.value === 'all';
                    } else {
                        button.disabled = false;
                    }
                });
                // Enable layer select
                layerSelect.disabled = false;
                // Enable all preview controls
                previewControls.forEach(control => {
                    control.disabled = false;
                });
            }
        }

        document.getElementById('plotterPlotLayer').addEventListener('click', async () => {
            const svg = container.querySelector('svg');
            if (!svg) return;
            
            const currentLayer = document.getElementById('layerSelect').value;
            if (currentLayer === 'all') return;
            
            // Get the full layer label to extract color information
            const layerSelect = document.getElementById('layerSelect');
            const selectedOption = layerSelect.options[layerSelect.selectedIndex];
            const layerLabel = selectedOption.textContent;
            
            try {
                logDebug(`Plotting layer ${layerLabel}...`);
                startProgressListener();  // Start listening for progress
                
                updatePlotterStatus('Plotting', true);  // Set status before starting plot
                
                const svgData = new XMLSerializer().serializeToString(svg);
                if (await sendPlotterCommand('plot', { 
                    svg: svgData, 
                    layer: currentLayer,
                    layerLabel: layerLabel 
                })) {
                    logDebug(`Layer ${layerLabel} plot command sent successfully`);
                } else {
                    throw new Error('Plot command failed to start');
                }
            } catch (error) {
                logDebug(`Plot failed: ${error.message}`, 'error');
                // Clean up SSE connection if it was started
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
                // Re-enable all controls
                updatePlotterStatus('Ready', true);
            }
        });


        // Add event listeners for new plotter buttons
        document.getElementById('plotterCycle').addEventListener('click', async () => {
            logDebug('Sending cycle command...');
            if (await sendPlotterCommand('cycle')) {
                logDebug('Cycle command completed');
                updatePlotterStatus('Ready', true);
            }
        });

        document.getElementById('plotterToggle').addEventListener('click', async () => {
            logDebug('Sending toggle command...');
            if (await sendPlotterCommand('toggle')) {
                logDebug('Toggle command completed');
                updatePlotterStatus('Ready', true);
            }
        });

        document.getElementById('plotterAlign').addEventListener('click', async () => {
            logDebug('Sending align command...');
            if (await sendPlotterCommand('align')) {
                logDebug('Align command completed');
                updatePlotterStatus('Ready', true);
            }
        });

        document.getElementById('plotterStopPlot').addEventListener('click', async () => {
            if (progressEventSource) {
                progressEventSource.close();
                progressEventSource = null;
            }
            logDebug('Sending stop plot command...');
            if (await sendPlotterCommand('stop_plot')) {
                logDebug('Stop plot command sent successfully');
                updatePlotterStatus('Ready', true);  // Reset status after stopping
            }
        });

        document.getElementById('plotterHome').addEventListener('click', async () => {
            logDebug('Sending home command...');
            if (await sendPlotterCommand('home')) {
                logDebug('Home command completed');
                updatePlotterStatus('Ready', true);
            }
        });

        document.getElementById('plotterDisableMotors').addEventListener('click', async () => {
            logDebug('Sending disable motors command...');
            if (await sendPlotterCommand('disable_motors')) {
                logDebug('Disable motors command completed');
                updatePlotterStatus('Ready', true);
            }
        });

        // Paper size selection handler
        document.getElementById('paperSelect').addEventListener('change', async (e) => {
            const paperSize = e.target.value;
            logDebug(`Changing paper size to ${paperSize}`);
            // Reload the drawing with new paper size
            await draw();
        });
    </script>
</body>
</html>
