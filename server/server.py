from http.server import HTTPServer, SimpleHTTPRequestHandler
import glob
import json
import os
import shutil
import sys
from datetime import datetime
import xml.dom.minidom
import pprint
import subprocess
import shlex
import threading
import time
import signal
import re
try:
    from plotter_config import PLOTTER_CONFIGS, CURRENT_PLOTTER
except ImportError:
    from .plotter_config import PLOTTER_CONFIGS, CURRENT_PLOTTER

try:
    import psutil
except ImportError:
    psutil = None


def wrap_command_with_sleep_blocker(cmd):
    try:
        if sys.platform == 'darwin' and shutil.which('caffeinate'):
            return ['caffeinate', '-dimsu', *cmd]
        if sys.platform.startswith('linux') and shutil.which('systemd-inhibit'):
            return ['systemd-inhibit', '--what=sleep', '--why', 'Plotting job', '--mode=block', *cmd]
    except Exception:
        pass
    return cmd


def sanitize_for_comment(value, max_length=240, depth=0):
    if isinstance(value, str):
        trimmed = value.strip()
        if len(trimmed) > max_length:
            return f"{trimmed[:max_length]}... [len={len(trimmed)}]"
        return trimmed
    if isinstance(value, (int, float, bool)) or value is None:
        return value
    if isinstance(value, dict):
        sanitized = {}
        for key, val in value.items():
            sanitized[key] = sanitize_for_comment(val, max_length, depth + 1)
        return sanitized
    if isinstance(value, list):
        if depth > 2 and len(value) > 20:
            trimmed_list = value[:20]
            sanitized = [sanitize_for_comment(item, max_length, depth + 1) for item in trimmed_list]
            sanitized.append(f"... ({len(value) - 20} more)")
            return sanitized
        return [sanitize_for_comment(item, max_length, depth + 1) for item in value]
    return str(value)


def format_block(title, data):
    if data is None or (isinstance(data, dict) and not data) or (isinstance(data, list) and not data):
        return f"{title}\n  (none)"
    formatted = pprint.pformat(data, indent=2, width=120)
    indented = '\n'.join(f"  {line}" for line in formatted.splitlines())
    return f"{title}\n{indented}"


def normalize_medium_info(raw_medium):
    if isinstance(raw_medium, dict):
        medium_id = raw_medium.get('id') or raw_medium.get('mediumId') or raw_medium.get('name') or 'unknown'
        metadata = raw_medium.get('metadata') if isinstance(raw_medium.get('metadata'), dict) else {}
        disabled = raw_medium.get('disabledColors')
        if isinstance(disabled, list):
            disabled_colors = [str(color) for color in disabled]
        elif isinstance(disabled, set):
            disabled_colors = [str(color) for color in sorted(disabled)]
        else:
            disabled_colors = []
        return {
            'id': medium_id,
            'metadata': metadata,
            'disabledColors': disabled_colors
        }
    if isinstance(raw_medium, str):
        return {
            'id': raw_medium,
            'metadata': {},
            'disabledColors': []
        }
    return {
        'id': 'unknown',
        'metadata': {},
        'disabledColors': []
    }


def build_config_comment(drawing_name, config):
    config = config or {}
    paper_info = config.get('paper') or {}
    sanitized_paper = sanitize_for_comment(paper_info)
    hatch_settings = sanitize_for_comment(config.get('hatch') or {})
    drawing_controls = sanitize_for_comment(config.get('drawingControls') or {})
    drawing_data_summary = sanitize_for_comment(config.get('drawingData') or {})
    medium_info = normalize_medium_info(config.get('medium'))
    medium_metadata_summary = sanitize_for_comment(medium_info.get('metadata'))
    disabled_colors = medium_info.get('disabledColors') or []
    paper_id = config.get('paperId') or paper_info.get('id') or 'unknown'
    orientation = paper_info.get('orientation', 'landscape')
    margin = config.get('paperMargin') or paper_info.get('margin', 'unknown')
    sections = [
        f"Generated by Plotter Art Generator",
        f"Date: {datetime.now().isoformat()}",
        f"Drawing: {drawing_name}",
        f"Paper: id={paper_id} name={paper_info.get('name', 'unknown')} "
        f"size={paper_info.get('width', 'unknown')}√ó{paper_info.get('height', 'unknown')}mm "
        f"orientation={orientation} margin={margin}mm",
        f"Medium: id={medium_info.get('id')} name={medium_info.get('metadata', {}).get('name', 'unknown')}",
        f"Disabled Colors: {', '.join(disabled_colors) if disabled_colors else 'none'}",
        format_block("Hatch Settings:", hatch_settings),
        format_block("Drawing Controls:", drawing_controls),
        format_block("Drawing Data Summary:", drawing_data_summary),
        format_block("Paper Metadata:", sanitized_paper),
        format_block("Medium Metadata:", medium_metadata_summary)
    ]
    return "<!--\n" + "\n".join(sections) + "\n-->\n"

class PlotterHandler(SimpleHTTPRequestHandler):
    AXIDRAW_PATH = "./bin/axicli"  # Path to the AxiDraw executable
    current_plot_process = None  # Track the current plotting process
    sse_connections = set()  # Track active SSE connections
    keep_sse_alive = True  # Control SSE connection lifecycle
    manifest_cache = {
        'mtime': None,
        'data': None
    }
    RESUME_LOG_PATH = os.path.join('output', 'plot_resume.log')
    resume_state_lock = threading.Lock()
    resume_state = {
        'path': None,
        'layer': None,
        'layer_label': None,
        'available': False
    }
    _RESUME_SENTINEL = object()
    plot_interrupted = False
    last_progress_bar = None

    @classmethod
    def _resolve_resume_path(cls, requested_path=None):
        return requested_path or cls.RESUME_LOG_PATH

    @classmethod
    def _prepare_resume_file(cls, resume_path):
        if not resume_path:
            return None
        directory = os.path.dirname(resume_path)
        if directory and not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)
        if os.path.exists(resume_path):
            os.remove(resume_path)
        return resume_path

    @classmethod
    def update_resume_state(cls, *, path=_RESUME_SENTINEL, layer=_RESUME_SENTINEL,
                            layer_label=_RESUME_SENTINEL, available=_RESUME_SENTINEL):
        with cls.resume_state_lock:
            if path is not cls._RESUME_SENTINEL:
                cls.resume_state['path'] = path
            if layer is not cls._RESUME_SENTINEL:
                cls.resume_state['layer'] = layer
            if layer_label is not cls._RESUME_SENTINEL:
                cls.resume_state['layer_label'] = layer_label
            if available is not cls._RESUME_SENTINEL:
                cls.resume_state['available'] = bool(available)

    @classmethod
    def register_resume_tracking(cls, resume_path, layer=None, layer_label=None):
        cls.update_resume_state(
            path=resume_path,
            layer=layer,
            layer_label=layer_label,
            available=False
        )

    @classmethod
    def mark_resume_available(cls, resume_path=None, layer=None, layer_label=None):
        path = resume_path or cls.resume_state.get('path')
        exists = bool(path) and os.path.exists(path)
        updates = {
            'available': exists
        }
        if path is not None:
            updates['path'] = path
        if layer is not None:
            updates['layer'] = layer
        if layer_label is not None:
            updates['layer_label'] = layer_label
        cls.update_resume_state(**updates)

    @classmethod
    def clear_resume_state(cls, remove_file=True):
        with cls.resume_state_lock:
            path = cls.resume_state.get('path')
        if remove_file and path and os.path.exists(path):
            try:
                os.remove(path)
            except OSError as e:
                print(f"Warning: failed to remove resume log {path}: {e}")
        cls.update_resume_state(path=None, layer=None, layer_label=None, available=False)

    @classmethod
    def get_resume_status(cls, include_path=False):
        with cls.resume_state_lock:
            state = dict(cls.resume_state)
        path = state.get('path')
        exists = bool(path) and os.path.exists(path)
        available = bool(state.get('available')) and exists
        payload = {
            'available': available,
            'layer': state.get('layer'),
            'layerLabel': state.get('layer_label')
        }
        if include_path:
            payload['path'] = path if exists else None
        return payload

    @classmethod
    def prepare_resume_file(cls, requested_path=None):
        resume_path = cls._resolve_resume_path(requested_path)
        return cls._prepare_resume_file(resume_path)

    @classmethod
    def execute_home_sequence(cls, pen_pos_up):
        if pen_pos_up is None:
            raise ValueError("pen_pos_up is required to home the plotter")
        pen_up_value = str(pen_pos_up)
        raise_pen_cmd = [
            cls.AXIDRAW_PATH,
            '--mode', 'manual',
            '--manual_cmd', 'raise_pen',
            '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
            '--pen_pos_up', pen_up_value,
            '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift'])
        ]
        walk_home_cmd = [
            cls.AXIDRAW_PATH,
            '--mode', 'manual',
            '--manual_cmd', 'walk_home',
            '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
            '--pen_pos_up', pen_up_value,
            '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift'])
        ]
        subprocess.run(raise_pen_cmd, capture_output=True, text=True, check=True)
        subprocess.run(walk_home_cmd, capture_output=True, text=True, check=True)
        cls.clear_resume_state()

    @classmethod
    def bootstrap_resume_state(cls):
        resume_path = cls._resolve_resume_path()
        if resume_path and os.path.exists(resume_path):
            cls.update_resume_state(path=resume_path, available=True)
        else:
            cls.update_resume_state(path=None, layer=None, layer_label=None, available=False)

    def do_GET(self):
        # Redirect root to plotter.html
        if self.path == '/':
            self.path = '/client/templates/plotter.html'
        request_path = self.path.split('?', 1)[0]
        if request_path == '/drawings-manifest.json':
            manifest = self.load_drawings_manifest()
            body = json.dumps(manifest).encode('utf-8')
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Content-Length', str(len(body)))
            self.end_headers()
            self.wfile.write(body)
            return
        if self.path == '/plot-progress':
            self.send_response(200)
            self.send_header('Content-Type', 'text/event-stream')
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Connection', 'keep-alive')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            
            # Add this connection to the set
            PlotterHandler.sse_connections.add(self)
            
            try:
                while PlotterHandler.keep_sse_alive:
                    # Send a heartbeat to keep connection alive
                    try:
                        self.wfile.write(b':\n\n')  # SSE comment as heartbeat
                        self.wfile.flush()
                    except (BrokenPipeError, ConnectionResetError):
                        break
                    time.sleep(0.1)  # Shorter sleep to be more responsive
            except (BrokenPipeError, ConnectionResetError):
                print("Client disconnected from SSE")
            finally:
                # Remove connection when client disconnects
                PlotterHandler.sse_connections.remove(self)
            return
        if self.path == '/resume-status':
            status = self.get_resume_status()
            body = json.dumps(status).encode('utf-8')
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Content-Length', str(len(body)))
            self.end_headers()
            self.wfile.write(body)
            return
            
        # Handle CSS file requests
        if self.path.startswith('/css/'):
            css_path = os.path.join('client/static', self.path.lstrip('/'))
            if os.path.exists(css_path):
                self.send_response(200)
                self.send_header('Content-Type', 'text/css')
                self.end_headers()
                with open(css_path, 'rb') as f:
                    self.wfile.write(f.read())
                return
        
        # Handle JS file requests
        if self.path.startswith('/js/'):
            # Strip off any URL parameters
            js_path = self.path.split('?')[0]
            js_path = os.path.join('client/', js_path.lstrip('/'))
            if os.path.exists(js_path):
                self.send_response(200)
                self.send_header('Content-Type', 'application/javascript')
                self.end_headers()
                with open(js_path, 'rb') as f:
                    self.wfile.write(f.read())
                return
        
        # Handle favicon.ico requests
        if self.path == '/favicon.ico':
            self.send_response(200)
            self.send_header('Content-Type', 'image/x-icon')
            self.end_headers()
            try:
                with open('client/static/favicon.ico', 'rb') as f:
                    self.wfile.write(f.read())
            except FileNotFoundError:
                # If favicon.ico doesn't exist, return empty response
                self.wfile.write(b'')
            return
        
        # Handle all other GET requests as normal
        return SimpleHTTPRequestHandler.do_GET(self)

    PROGRESS_BAR_REGEX = re.compile(r'Plot Progress:\s*(?P<bar>.+)$')

    @classmethod
    def emit_progress_bar(cls, handler, bar_text):
        if bar_text == cls.last_progress_bar:
            return
        cls.last_progress_bar = bar_text
        payload = {'status': bar_text}
        handler.send_progress_update('CLI_PROGRESS_BAR', payload)

    def _handle_plot_stdout_line(self, line):
        stripped = line.strip()
        if not stripped:
            return
        bar_match = self.PROGRESS_BAR_REGEX.search(stripped)
        if bar_match:
            bar_text = bar_match.group('bar').strip()
            self.emit_progress_bar(self, bar_text)
            print(f"Plot progress bar: {stripped}")
            return
        try:
            parsed = json.loads(stripped)
        except (json.JSONDecodeError, TypeError):
            parsed = None
        if isinstance(parsed, dict) and 'progress_event' in parsed:
            event = parsed['progress_event']
            self.send_progress_update('CLI_PROGRESS', event)
            status = event.get('status') if isinstance(event, dict) else None
            progress_pct = event.get('progress') if isinstance(event, dict) else None
            if status:
                pct_display = f" ({progress_pct * 100:.1f}%)" if isinstance(progress_pct, (int, float)) else ""
                print(f"Plot progress: {status}{pct_display}")
            else:
                print(f"Plot progress event: {parsed['progress_event']}")
            return
        print(f"Plot output: {stripped}")
        self.send_progress_update(stripped)

    def _handle_plot_stderr_line(self, line):
        stripped = line.strip()
        if not stripped:
            return
        lower = stripped.lower()
        if stripped.startswith('Plot Progress:'):
            bar_text = stripped[len('Plot Progress:'):].strip()
            self.emit_progress_bar(self, bar_text)
            print(f"Plot progress bar (stderr): {stripped}")
            return
        elif "estimated print time" in lower:
            print(f"Plot info: {stripped}")
            self.send_progress_update(stripped)
        elif "error" in lower:
            print(f"Plot error: {stripped}")
            self.send_progress_update(f"Error: {stripped}")
        else:
            print(f"Plot info: {stripped}")
            self.send_progress_update(stripped)

    def _stream_pipe(self, pipe, handler):
        try:
            for raw_line in iter(pipe.readline, ''):
                if not raw_line:
                    break
                handler(raw_line)
        except Exception as stream_error:
            print(f"Error reading plot stream: {stream_error}")
        finally:
            try:
                pipe.close()
            except Exception:
                pass

    def _run_axidraw_process(self, cmd):
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True
        )
        PlotterHandler.current_plot_process = process

        stdout_thread = threading.Thread(
            target=self._stream_pipe,
            args=(process.stdout, self._handle_plot_stdout_line),
            daemon=True
        )
        stderr_thread = threading.Thread(
            target=self._stream_pipe,
            args=(process.stderr, self._handle_plot_stderr_line),
            daemon=True
        )
        stdout_thread.start()
        stderr_thread.start()

        try:
            returncode = process.wait()
            stdout_thread.join(timeout=1)
            stderr_thread.join(timeout=1)
            return returncode
        finally:
            PlotterHandler.current_plot_process = None

    @classmethod
    def load_drawings_manifest(cls):
        manifest_path = os.path.join(os.getcwd(), 'drawings', 'manifest.json')
        try:
            mtime = os.path.getmtime(manifest_path)
        except OSError:
            return {
                'version': 'missing',
                'generatedAt': datetime.utcnow().isoformat() + 'Z',
                'drawings': []
            }

        if cls.manifest_cache['mtime'] == mtime and cls.manifest_cache['data'] is not None:
            return cls.manifest_cache['data']

        with open(manifest_path, 'r', encoding='utf-8') as manifest_file:
            data = json.load(manifest_file)
            cls.manifest_cache = {
                'mtime': mtime,
                'data': data
            }
            return data

    def handle_command(self, command_data):
        """Handle plotter commands by executing AxiDraw CLI commands"""
        command = command_data.get('command')
        # Use all data except 'command' as params
        params = {k: v for k, v in command_data.items() if k != 'command'}
        
        # Dictionary mapping commands to their CLI parameters
        def plot_command(params):
            PlotterHandler.keep_sse_alive = True  # Reset SSE state for new plot
            PlotterHandler.plot_interrupted = False
            if 'layer' not in params:
                print("Error: No layer specified in plot command")
                raise ValueError("No layer specified in plot command")
            try:
                PlotterHandler.execute_home_sequence(params.get('pen_pos_up'))
            except Exception as home_error:
                print(f"Error homing before plot: {home_error}")
                return {
                    'status': 'error',
                    'message': f'Failed to home plotter before plotting: {home_error}'
                }

            # Create temp file for SVG if present
            temp_svg_path = None
            resume_path = None
            PlotterHandler.last_progress_bar = None
            try:
                if 'svg' in params:
                    temp_svg_path = f'temp_{datetime.now().strftime("%Y%m%d_%H%M%S")}.svg'
                    with open(temp_svg_path, 'w', encoding='utf-8') as f:
                        f.write(params['svg'])
                    resume_path = PlotterHandler.prepare_resume_file(params.get('resume_path'))
                    PlotterHandler.register_resume_tracking(
                        resume_path,
                        layer=params.get('layer'),
                        layer_label=params.get('layerLabel')
                    )
            except IOError as e:
                print(f"Error writing temporary SVG file: {e}")
                return {
                    'status': 'error',
                    'message': f'Failed to create temporary file: {str(e)}'
                }
            
            def run_plot():
                try:
                    # Build command array with filename as first parameter after axicli
                    cmd = [self.AXIDRAW_PATH]
                    if temp_svg_path:
                        cmd.append(temp_svg_path)
                    cmd.extend([
                        '--mode', 'layers',
                        '--layer', str(params['layer']),
                        '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
                        '--pen_pos_up', str(params['pen_pos_up']),
                        '--pen_pos_down', str(params['pen_pos_down']),
                        '--pen_rate_lower', str(params.get('pen_rate_lower', 25)),
                        '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift']),
                        '--progress'
                    ])
                    if resume_path:
                        cmd.extend(['--output_file', resume_path])
                    cmd = wrap_command_with_sleep_blocker(cmd)

                    print(f"Executing command for layer number: {params.get('layer', '1')}")
                    print(f"Executing command for layer label: {params.get('layerLabel', 'unknown')}")
                    print(f"Executing: {' '.join(cmd)}")
                    returncode = self._run_axidraw_process(cmd)
                    if PlotterHandler.plot_interrupted:
                        interrupt_code = returncode if returncode not in (None, 0) else 1
                        PlotterHandler.plot_interrupted = False
                        raise subprocess.CalledProcessError(interrupt_code, cmd)
                    if returncode != 0:
                        raise subprocess.CalledProcessError(returncode, cmd)
                    PlotterHandler.clear_resume_state()
                    self.send_progress_update("Plot completed successfully")
                    self.send_progress_update("PLOT_COMPLETE")  # Special message for client
                except Exception as e:
                    PlotterHandler.mark_resume_available(resume_path, params.get('layer'), params.get('layerLabel'))
                    PlotterHandler.plot_interrupted = False
                    print(f"Error in plot thread: {e}")
                    self.send_progress_update(f"Error: {str(e)}")
                    self.send_progress_update("PLOT_ERROR")  # New special message for client
                finally:
                    # Clean up temp file if it was created
                    if temp_svg_path:
                        try:
                            if os.path.exists(temp_svg_path):
                                os.remove(temp_svg_path)
                        except OSError as e:
                            print(f"Error removing temporary file {temp_svg_path}: {e}")

            # Start the plot in a separate thread
            plot_thread = threading.Thread(target=run_plot)
            plot_thread.daemon = True  # Make thread daemon so it doesn't block program exit
            plot_thread.start()
            
            return {
                'status': 'success',
                'message': 'Plot command started'
            }
        def resume_plot_command(_):
            PlotterHandler.keep_sse_alive = True
            PlotterHandler.plot_interrupted = False
            status = self.get_resume_status(include_path=True)
            resume_path = status.get('path')
            if not resume_path or not os.path.exists(resume_path):
                return {
                    'status': 'error',
                    'message': 'No resume file available'
                }
            PlotterHandler.update_resume_state(available=False)

            def run_resume():
                try:
                    cmd = [
                        self.AXIDRAW_PATH,
                        resume_path,
                        '--mode', 'res_plot',
                        '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
                        '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift']),
                        '--progress'
                    ]
                    cmd.extend(['--output_file', resume_path])
                    cmd = wrap_command_with_sleep_blocker(cmd)

                    print("Resuming plot from resume log")
                    print(f"Executing: {' '.join(cmd)}")

                    returncode = self._run_axidraw_process(cmd)
                    if returncode != 0:
                        raise subprocess.CalledProcessError(returncode, cmd)
                    PlotterHandler.clear_resume_state()
                    self.send_progress_update("Plot resumed successfully")
                    self.send_progress_update("PLOT_COMPLETE")
                except Exception as e:
                    PlotterHandler.mark_resume_available(resume_path, status.get('layer'), status.get('layerLabel'))
                    print(f"Error resuming plot: {e}")
                    self.send_progress_update(f"Error: {str(e)}")
                    self.send_progress_update("PLOT_ERROR")

            resume_thread = threading.Thread(target=run_resume)
            resume_thread.daemon = True
            resume_thread.start()
            return {
                'status': 'success',
                'message': 'Resume command started'
            }

        commands = {
            'plot': plot_command,
            'resume_plot': resume_plot_command,
            'toggle': lambda params: [
                self.AXIDRAW_PATH,
                '--mode', 'toggle',
                '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
                '--pen_pos_up', str(params['pen_pos_up']),
                '--pen_pos_down', str(params['pen_pos_down']),
                '--pen_rate_lower', str(params.get('pen_rate_lower', 25)),
                '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift'])
            ],
            'align': lambda params: [
                self.AXIDRAW_PATH,
                '--mode', 'align',
                '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
                '--pen_pos_up', str(params['pen_pos_up']),
                '--pen_pos_down', str(params['pen_pos_down']),
                '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift'])
            ],
            'cycle': lambda params: [
                self.AXIDRAW_PATH,
                '--mode', 'cycle',
                '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
                '--pen_pos_up', str(params['pen_pos_up']),
                '--pen_pos_down', str(params['pen_pos_down']),
                '--pen_rate_lower', str(params.get('pen_rate_lower', 25)),
                '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift'])
            ],
            'home': lambda _: None,  # Special case handled below
            'disable_motors': lambda _: [
                self.AXIDRAW_PATH,
                '--mode', 'manual',
                '--manual_cmd', 'disable_xy',
                '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
                '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift'])
            ],
            'raise_pen': lambda params: [
                self.AXIDRAW_PATH,
                '--mode', 'manual',
                '--manual_cmd', 'raise_pen',
                '--model', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['model']),
                '--pen_pos_up', str(params['pen_pos_up']),
                '--penlift', str(PLOTTER_CONFIGS[CURRENT_PLOTTER]['penlift'])
            ],
            'stop_plot': lambda _: None  # Special case handled below
        }
        
        if command not in commands:
            return {'status': 'error', 'message': f'Unknown command: {command}'}
            
        try:
            if command == 'stop_plot':
                print("\nExecuting stop_plot command...")
                PlotterHandler.keep_sse_alive = False  # Stop SSE connections
                if PlotterHandler.current_plot_process:
                    print(f"Found current plot process (PID: {PlotterHandler.current_plot_process.pid})")
                    PlotterHandler.plot_interrupted = True
                    # Politely interrupt the process so axicli can flush resume log
                    try:
                        PlotterHandler.current_plot_process.send_signal(signal.SIGINT)
                        print("Sent SIGINT to plotting process")
                    except Exception as sig_error:
                        print(f"Failed to send SIGINT ({sig_error}), terminating instead")
                        PlotterHandler.current_plot_process.terminate()
                    try:
                        print("Waiting for process to terminate...")
                        PlotterHandler.current_plot_process.wait(timeout=5)
                        print("Process terminated successfully")
                    except subprocess.TimeoutExpired:
                        print("Process did not terminate, attempting to kill...")
                        PlotterHandler.current_plot_process.kill()
                        print("Process killed")
                    PlotterHandler.current_plot_process = None
                    PlotterHandler.mark_resume_available()
                    return {'status': 'success', 'message': 'Plot stopped'}
                else:
                    print("No current plot process found, searching for stray processes...")
                    found_stray = False
                    if psutil:
                        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                            if 'axicli' in str(proc.info.get('name', '')) or \
                               (proc.info.get('cmdline') and any('axicli' in str(cmd) for cmd in proc.info['cmdline'])):
                                print(f"Found stray axicli process (PID: {proc.pid})")
                                proc.terminate()
                                try:
                                    print(f"Waiting for stray process {proc.pid} to terminate...")
                                    proc.wait(timeout=5)
                                    print(f"Stray process {proc.pid} terminated successfully")
                                except (psutil.TimeoutExpired, AttributeError):
                                    print(f"Stray process {proc.pid} did not terminate, attempting to kill...")
                                    proc.kill()
                                    print(f"Stray process {proc.pid} killed")
                                found_stray = True
                    else:
                        print("psutil not available; cannot inspect stray processes")
                    if found_stray:
                        PlotterHandler.mark_resume_available()
                    if found_stray:
                        return {'status': 'success', 'message': 'Stray plot process stopped'}
                    print("No axicli processes found")
                    return {'status': 'success', 'message': 'No active plot to stop'}
            elif command in ('plot', 'resume_plot'):
                return commands[command](params)
            elif command == 'home':
                PlotterHandler.execute_home_sequence(params.get('pen_pos_up'))
                PlotterHandler.clear_resume_state()
                return {
                    'status': 'success',
                    'message': 'Home sequence completed successfully'
                }
            else:
                # Handle other non-plot commands
                cmd_array = commands[command](params)
                result = subprocess.run(
                    cmd_array,
                    capture_output=True,
                    text=True,
                    check=True
                )
                return {
                    'status': 'success',
                    'message': result.stdout.strip() or 'Command executed successfully'
                }
                    
        except subprocess.CalledProcessError as e:
            error_msg = e.stderr.strip() if e.stderr else str(e)
            return {
                'status': 'error',
                'message': f'Command failed: {error_msg}'
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Error executing command: {str(e)}'
            }
    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()

    def do_POST(self):
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data.decode('utf-8'))
            
            # Add this debug print
            print(f"\nReceived command data:")
            print(json.dumps(data, indent=2))

            if self.path == '/save-svg':
                try:
                    # Create output directory and drawing-specific subdirectory
                    output_dir = os.path.join('output', data['name'])
                    try:
                        os.makedirs(output_dir, exist_ok=True)
                    except OSError as e:
                        print(f"Error creating output directory: {e}")
                        raise Exception(f"Failed to create output directory: {str(e)}")

                    # Generate filename with timestamp
                    timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
                    filename = os.path.join(output_dir, f"{timestamp}.svg")
                    
                    try:
                        # Pretty print the SVG
                        dom = xml.dom.minidom.parseString(data['svg'])
                        pretty_svg = dom.toprettyxml(indent='  ')
                    except xml.parsers.expat.ExpatError as e:
                        print(f"Error parsing SVG data: {e}")
                        raise Exception(f"Invalid SVG data: {str(e)}")
                    svg_lines = pretty_svg.splitlines()
                    if svg_lines and svg_lines[0].lstrip().startswith('<?xml'):
                        svg_lines = svg_lines[1:]
                    pretty_svg = '\n'.join(svg_lines).strip() + '\n'
                    
                    # Add configuration as comment at the top
                    config = data.get('config', {})
                    config_comment = build_config_comment(data['name'], config)
                    final_svg = config_comment + pretty_svg
                    
                    # Write the SVG file
                    try:
                        with open(filename, 'w', encoding='utf-8') as f:
                            f.write(final_svg)
                    except IOError as e:
                        print(f"Error writing SVG file: {e}")
                        raise Exception(f"Failed to write SVG file: {str(e)}")
                    
                    # Send response
                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({
                        'status': 'success',
                        'filename': filename
                    }).encode())
                except Exception as e:
                    print(f"Error handling save-svg: {e}")
                    self.send_response(500)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({
                        'status': 'error',
                        'message': str(e)
                    }).encode())
            elif self.path == '/plotter':
                # Handle plotter commands
                response = self.handle_command(data)
                
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(response).encode())
            else:
                # Handle non-matching paths with 404
                self.send_response(404)
                self.end_headers()
                self.wfile.write(b'Not Found')
        except Exception as e:
            print(f"Error handling POST: {e}")
            self.send_response(500)
            self.end_headers()
            self.wfile.write(str(e).encode())
    
    def send_progress_update(self, message, payload=None):
        envelope = {'progress': message}
        if payload is not None:
            envelope['payload'] = payload
        data = f"data: {json.dumps(envelope)}\n\n".encode('utf-8')
        # Send to all active connections
        disconnected = set()
        for connection in PlotterHandler.sse_connections:
            try:
                connection.wfile.write(data)
                connection.wfile.flush()
            except Exception as e:
                print(f"Error sending progress update to client: {e}")
                disconnected.add(connection)
        
        # Clean up any disconnected clients
        PlotterHandler.sse_connections.difference_update(disconnected)

    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        SimpleHTTPRequestHandler.end_headers(self)

def cleanup_temp_files():
    """Clean up any temporary SVG files from previous runs"""
    try:
        # Look for files matching the temp file pattern
        temp_pattern = "temp_*.svg"
        count = 0
        for temp_file in glob.glob(temp_pattern):
            try:
                os.remove(temp_file)
                count += 1
            except OSError as e:
                print(f"Error removing temporary file {temp_file}: {e}")
        if count > 0:
            print(f"üßπ Cleaned up {count} temporary SVG file{'s' if count != 1 else ''}")
    except Exception as e:
        print(f"‚ùå Error during cleanup: {e}")

def create_server():
    try:
        cleanup_temp_files()  # Add cleanup call
        PlotterHandler.bootstrap_resume_state()
        server_address = ('', 8000)
        httpd = HTTPServer(server_address, PlotterHandler)
        print('üöÄ Server running on http://localhost:8000')
        return httpd
    except Exception as e:
        print(f"‚ùå Error creating server: {e}")
        raise

if __name__ == '__main__':
    try:
        httpd = create_server()
        httpd.serve_forever()
    except KeyboardInterrupt:
        print('\nüëã Server shutting down...')
        httpd.server_close()
    except Exception as e:
        print(f"‚ùå Server error: {e}")
